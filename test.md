# 前端面试总结

js html css
# js

## 面向对象
对象的定义: 无序属性的集合，其属性可以包含基本值，对象或者函数

代码示例：
var person={
    name:"test",
    getName:function(){

    },
    son:{},
    parent:{}
}
创建对象 var obj=new Object() 
对象字面量的形式  var obj={}

var person={
    name:"test",
    age:"12"
    getName:function(){
        return this.name
    },
    getAge:function(){
        return this.age
    }
}
访问对象属性和方法
person.name
person['name']

## 构造函数
关于构造函数，理解new具体发生了什么
new构造函数与普通函数的不同，new的过程
1:声明一个中间对象
2:将该中间对象的原型指向构造函数的原型
3：将构造函数的this，指向该中间对象
4:返回该中间对象，即返回实例对象
## 原型
我们创建的每个函数，都有个prototype属性，该属性指向一个对象。这个对象就是我们这里说的原型。

## 原型链 继承
构造函数继承
原型继承

## this
指向，是在函数被调用的时候确定的，也就是执行上下文被创建时确定的。
1.全局对象中的this
2.函数中的this
3.使用call，apply显示制定this

## js模块化




## 事件循环(event loop)
既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：

同步任务
异步任务

当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：


导图要表达的内容用文字来表述的话：

同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数。
当指定的事情完成时，Event Table会将这个函数移入Event Queue。
主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。
上述过程会不断重复，也就是常说的Event Loop(事件循环)。

我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。
说了这么多文字，不如直接一段代码更直白：
let data = [];
$.ajax({
    url:www.javascript.com,
    data:data,
    success:() => {
        console.log('发送成功!');
    }
})
console.log('代码执行结束');
复制代码
上面是一段简易的ajax请求代码：

ajax进入Event Table，注册回调函数success。
执行console.log('代码执行结束')。
ajax事件完成，回调函数success进入Event Queue。
主线程从Event Queue读取回调函数success并执行。

相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。




## 执行上下文

## 浏览器原理
浏览器是多进程架构
1：主进程 2：渲染进程(内核) 3：插件进程 4:GPU进程 5:网络进程

1.主进程：界面显示，用户交互，子进程管理，存储等功能
2：渲染进程：html,css,javascript，转换为用户可以与之交互的网页，排版引擎Blink和javascript引擎V8运行在该进程中，每个tab标签创建一个渲染进程。渲染进程运行在沙箱模式下。
3：GPU进程：绘制网页
4：网络进程：页面的网络资源加载
5：插件进程：负责插件的运行

### 渲染进程
1.构建DOM树
HTML内容转换为浏览器dom树结构

2.样式计算
格式化样式表
标准化样式表
计算每个dom节点具体样式

3.布局阶段
布局系统确定元素位置，生成一颗布局树，渲染树

4.分层
浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层

5、绘制
绘制图层的操作在渲染进程中有着专门的线程，这个线程叫做合成线程

6、分块
7、光栅化
栅格化，是指将图块转换为位图

8、合成

## http/0.9 http/1.0 http/1.1(标准) http/2.0 http/3.0

### http/0.9:
协议定义了客户端发起请求、服务端响应请求的通信模式。请求报文内容只有 1 行
GET + 请求的文件路径,传输纯文本

### http/1.0
随着互联网的发展以及浏览器的出现，单纯的文本内容已经无法满足用户需求了，浏览器希望通过 HTTP 来传输脚本、样式、图片、音频和视频等不同类型的文件，所以在 1996 年 HTTP 更新的 1.0 版本中引入了如下特性：

增加了 HEAD、POST 等新方法
增加了响应状态码，标记可能的错误原因
引入了协议版本号概念
引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活
传输的数据不再局限于文本
其中最核心的改变是增加了头部设定，头部内容以键值对的形式设置。请求头部通过 Accept 字段来告诉服务端可以接收的文件类型，响应头部再通过 Content-Type 字段来告诉浏览器返回文件的类型。

头部字段不仅用于解决不同类型文件传输的问题，也可以实现其他很多功能如缓存、认证信息等。

### http/1.1(标准)
随着互联网的迅速发展，HTTP/1.0 也已经无法满足需求，最核心的就是 连接 问题。

具体来说就是 HTTP/1.0 每进行一次通信，都需要经历建立连接、传输数据和断开连接三个阶段。当一个页面引用了较多的外部文件时，这个建立连接和断开连接的过程就会增加大量网络开销

长连接（Connection：keep-alive）：引入了 TCP 连接复用，即一个 TCP 默认不关闭，可以被多个请求复用
并发连接：对一个域名的请求允许分配多个长连接（缓解了长连接中的「队头阻塞」问题）
引入管道机制，一个 TCP 连接，可以同时发送多个请求。（响应的顺序必须和请求的顺序一致，因此不常用）
增加了 PUT、DELETE、OPTIONS、PATCH 等新的方法
新增缓存字段（cache-control E-tag）
请求头中引入了 range 字段，支持断点续传
允许响应数据分块（chunked），利于传输大文件
强制要求 Host 头，让互联网主机托管称为可能

### http/2.0
HTTP/1.1 通过长连接减少了大量创建/断开连接造成的性能消耗，但是它的并发能力受到限制，表现在两个方面：

HTTP/1.1 中使用持久连接时，一个连接中同一时刻只能处理一个请求。当前的请求没有结束之前，其他的请求只能处于阻塞状态，这种情况被称为「队头阻塞」
浏览器为了减轻服务器的压力，限制了同一个域名下的 HTTP 连接数，即 6 ~ 8 个
2015 年正式发布的 HTTP/2 默认不再使用 ASCII 编码传输，而是改为二进制数据，来提升传输效率。

客户端在发送请求时会将每个请求的内容封装成不同的带有编号的二进制帧（Frame），然后将这些帧同时发送给服务端。服务端接收到数据之后，会将相同编号的帧合并为完整的请求信息。同样，服务端返回结果、客户端接收结果也遵循这个帧的拆分与组合的过程。

有了二进制分帧后，对于同一个域，客户端只需要与服务端建立一个连接即可完成通信需求，这种利用一个连接来发送多个请求的方式称为「多路复用」。每一条路都被称为一个 stream（流）。

HTTP/2.0 的主要改动包括：

数据通过二进制协议传输，不再是纯文本
多路复用，废弃了 1.1 中的管道
使用专用算法压缩头部，减少数据传输量
通过设置数据帧的优先级，让服务器优先处理某些请求
允许服务器主动向客户推送数据
头部字段全部改为小写；引入了伪头部的概念，出现在头部字段之前，以冒号开头
增强了安全性，“事实上”要求加密通信

### http/3.0
当然 HTTP/2 也并非完美，如果客户端或服务端在通信时出现数据包丢失，或者任何一方的网络出现中断，那么整个 TCP 连接就会暂停。

HTTP/2 由于采用二进制分帧进行多路复用，通常只使用一个 TCP 连接进行传输，在丢包或网络中断的情况下后面的所有数据都被阻塞。

但对于 HTTP/1.1 来说，可以开启多个 TCP 连接，任何一个 TCP 出现问题都不会影响其他 TCP 连接，剩余的 TCP 连接还可以正常传输数据。这种情况下 HTTP/2 的表现就不如 HTTP/1 了。

2018 年 HTTP/3 将底层依赖的 TCP 改成 UDP，从而彻底解决了这个问题。UDP 相对于 TCP 而言最大的特点是传输数据时不需要建立连接，可以同时发送多个数据包，所以传输效率很高，缺点就是没有确认机制来保证对方一定能收到数据。

### 总结

协议版本	解决的核心问题	            解决方式

0.9	       HTML 文件传输	         确立了客户端请求、服务端响应的通信流程
1.0	       不同类型文件传输	          设立头部字段
1.1	       创建/断开 TCP 连接开销大	  建立长连接进行复用
2	       并发数有限	              二进制分帧
3	       TCP 丢包阻塞	              采用 UDP 协议

主要特点：

HTTP 1.0： GET + 请求的文件路径，服务端收到请求后返回一个以 ASCII 字符流编码的 HTML 文档。
HTTP 1.0：支持最基本的 GET、POST 方法、引入 header、传输的数据不局限于纯文本
HTTP 1.1：增减缓存策略、支持长连接、支持断点续传，状态码 206、支持新的方法 PUT，DELETE 等，可用于 Restful API
HTTP 2.0：数据通过二进制协议传输、支持压缩 header，减少体积、多路复用，一次 TCP 连接中可以多个 HTTP 并行请求、服务端推送


## http报文详解
### 客户端请求
1.请求行：包括了客户端的请求方法，URI、HTTP版本
2.请求头
3.请求体
### 服务端响应
1.响应行：包括HTTP版本、状态码
2.响应头
3.响应体
### http请求方法
GET:获取资源
POST：传输实体主体
PUT：传输文件
PATCH：用于对资源进行部分修改
HEAD：获取报文首部，与GET相比，不返回报文主体部分；使用场景是比如下载一个大文件前，先获取其大小再决定是否要下载，以此可以节约宽带资源
DELETE:删除文件
OPTIONS：(浏览器自动执行)、询问支持的请求方法，用来跨域请求、预检请求、判断目标是否安全
CONNECT：要求在与代理服务器通信时建立管道，使用管道进行TCP通信；(把服务器作为跳板，让服务器代替用户去访问其他网页，之后把数据原原本本的返回给用户)
TRACE: 该方法会让服务器原样返回任意客户端请求的信息内容，主要⽤于测试或诊断。

## http
1.构建请求：浏览器构建请求行信息 get/index.html http1.1。
2.查找缓存
3.准备ip和端口：通过域名系统(DNS)拿到ip地址
4.等待TCP队列
5.建立TCP连接：建立连接(三次握手)，传输数据，断开连接(四次挥手)
6.发起http请求：请求行，请求头，请求体(携带post传参)
7.服务器处理请求：响应行，响应头，响应体
8.服务器返回请求：浏览器开始渲染进程

## 缓存
浏览器缓存是将文件保存在客户端
页面的缓存状态是由header决定的
### 1.强缓存
response headers
http1.1 cache-control:max-age,s-maxage,public,private,no-cache,
no-store,must-revalidate
max-age:缓存最大的有效时间
s-maxage:用于共享缓存(CDN缓存)
public:指定响应会被缓存，并且在多用户间共享
private：响应只作为私有的缓存，不能在用户间共享。HTTP认证，响应会自动
设置为private
no-cache：指定不缓存响应，资源不进行缓存，加上private
no-store:绝对禁止缓存
must-revalidate:指定如果页面是过期的，则去服务器进行获取

http1.0 Expires=max-age+ 请求时间(cache-control 优先级更高)

### 2.协商缓存
response headers
#### 1、last-modified：
服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次请求，会向服务器传送if-modified-since报头，询问last-modified时间点之后资源是否被修改过。如果没有，返回304，使用缓存；如果修改过，则再次去服务器请求资源，返回200，最新资源

#### 2、etag：
根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器字符串传回服务器，服务端检查etag，验证资源是否已经修改，没修改返回304，空响应

#### 3、etag:解决的问题
a、某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新 
b、如果资源修改非常频繁，在秒以下的时间内进行修改，而Last-modified只能精确到秒 
c、一些资源的最后修改时间改变了，但是内容没改变，使用ETag就认为资源还是没有修改的。
last-modified：是根据文件的修改时间作唯一标示
etag：根据资源内容在服务器端的唯一标识符，更加准确的控制缓存

#### 4、last-modified/if-modified-since要配合cache-control
Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。
If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头:
If-Modified-Since:Last-Modified的值
web服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304,告知浏览器继续使用所保存的cache

#### Etag/If-None-Match 配合Cache-Control使用。
Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）.
If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头：
If-None-Match：Etag的值
web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定返回200或304。

#### LocalStorage和sessionStorage。



## 跨域
一、什么是跨域？
1.什么是同源策略及其限制内容？
同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

同源策略限制内容有：

Cookie、LocalStorage、IndexedDB 等存储性内容
DOM 节点
AJAX 请求发送后，结果被浏览器拦截了

但是有三个标签是允许跨域加载资源：

<img src=XXX>
<link href=XXX>
<script src=XXX>

.常见跨域场景
当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。常见跨域场景如下图所示：

    特别说明两点：
第一：如果是协议和端口造成的跨域问题“前台”是无能为力的。
第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名和端口必须匹配”。
这里你或许有个疑问：请求跨域了，那么请求到底发出去没有？
跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。




二、跨域解决方案

1.jsonp
1) JSONP原理
利用 <script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。
2) JSONP和AJAX对比
JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）
3) JSONP优缺点
JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。


2.cors
CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。
浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。
服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。


1) 简单请求
只要同时满足以下两大条件，就属于简单请求
条件1：使用下列方法之一：

GET
HEAD
POST

条件2：Content-Type 的值仅限于下列三者之一：

text/plain
multipart/form-data
application/x-www-form-urlencoded

请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。

2) 复杂请求
不符合以上条件的请求就肯定是复杂请求了。
复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。
我们用PUT向后台请求时，属于复杂请求，后台需做如下配置：

3.postMessage
postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：

页面和其打开的新窗口的数据传递
多窗口之间消息传递
页面与嵌套的iframe消息传递
上面三个场景的跨域数据传递

postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。

otherWindow.postMessage(message, targetOrigin, [transfer]);


message: 将要发送到其他 window的数据。
targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。
transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

接下来我们看个例子： http://localhost:3000/a.html页面向http://localhost:4000/b.html传递“我爱你”,然后后者传回"我不爱你"。

4.websocket
Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。
原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。
我们先来看个例子：本地文件socket.html向localhost:3000发生数据和接受数据

6.nginx反向代理
实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。
使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。
实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。
先下载nginx，然后将nginx目录下的nginx.conf修改如下:

7.window.name + iframe
window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。
其中a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000

8.location.hash +  iframe
实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
具体实现步骤：一开始a.html给c.html传一个hash值，然后c.html收到hash值后，再把hash值传递给b.html，最后b.html将结果放到a.html的hash值中。
同样的，a.html和b.html是同域的，都是http://localhost:3000;而c.html是http://localhost:4000

9.document.domain + iframe
该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
只需要给页面添加 document.domain ='test.com' 表示二级域名都相同就可以实现跨域。
实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
我们看个例子：页面a.zf1.cn:3000/a.html获取页面b.zf1.cn:3000/b.html中a的值

三、总结

CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。
日常工作中，用得比较多的跨域方案是cors和nginx反向代理










## 输入url显示页面过程
一.用户输入url
1.浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL

二.URL 请求过程
1.网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程

2.网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息

3.TCP三次握手建立连接，TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输

4.网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层

5.底层通过物理网络传输给目的服务器主机，紧接着目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层

6.目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层

7.应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了

8.网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型（Content-Type： application/octet-stream，下载），就将该请求交给下载管理器；如果是（Content-Type：text/html）类型，就通知浏览器进程获取到文档准备渲染

9.浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程。

10.浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程

11.浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页。

12.渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来





# 框架(vue react)


# 数据结构和算法

## 栈：只能操作一端
## 队列：可以操作两端

# 设计模式：
1.工厂模式:解决创建对象有重复的属性和方法
直接上代码
var createPerson=function(name,age){
    var obj=new Object()

    obj.name=name
    obj.age=age
    obj.getName=function(){
        return this.name
    }
    return obj
}
 创建实例
 var jc=createPerson('js',10)

# seo
### 产生304
服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。
状态码304不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。
搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。

304状态码出现过多会造成以下问题：

网站快照停止；
收录减少；
权重下降。

# 工程化

# git  

# 工程化 技术难点 团队协作


