# 前端面试总结

js html css
# js

## 面向对象
对象的定义: 无序属性的集合，其属性可以包含基本值，对象或者函数

代码示例：
var person={
    name:"test",
    getName:function(){

    },
    son:{},
    parent:{}
}
创建对象 var obj=new Object() 
对象字面量的形式  var obj={}

var person={
    name:"test",
    age:"12"
    getName:function(){
        return this.name
    },
    getAge:function(){
        return this.age
    }
}
访问对象属性和方法
person.name
person['name']

## 构造函数
关于构造函数，理解new具体发生了什么
new构造函数与普通函数的不同，new的过程
1:声明一个中间对象
2:将该中间对象的原型指向构造函数的原型
3：将构造函数的this，指向该中间对象
4:返回该中间对象，即返回实例对象
## 原型
我们创建的每个函数，都有个prototype属性，该属性指向一个对象。这个对象就是我们这里说的原型。

## 原型链 继承
构造函数继承
原型继承

## this
指向，是在函数被调用的时候确定的，也就是执行上下文被创建时确定的。
1.全局对象中的this
2.函数中的this
3.使用call，apply显示制定this

## 事件循环(event loop)

## 执行上下文

## 浏览器原理
浏览器是多进程架构
1：主进程 2：渲染进程(内核) 3：插件进程 4:GPU进程 5:网络进程

1.主进程：界面显示，用户交互，子进程管理，存储等功能
2：渲染进程：html,css,javascript，转换为用户可以与之交互的网页，排版引擎Blink和javascript引擎V8运行在该进程中，每个tab标签创建一个渲染进程。渲染进程运行在沙箱模式下。
3：GPU进程：绘制网页
4：网络进程：页面的网络资源加载
5：插件进程：负责插件的运行

### 渲染进程
1.构建DOM树
HTML内容转换为浏览器dom树结构

2.样式计算
格式化样式表
标准化样式表
计算每个dom节点具体样式

3.布局阶段
布局系统确定元素位置，生成一颗布局树，渲染树

4.分层
浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层

5、绘制
绘制图层的操作在渲染进程中有着专门的线程，这个线程叫做合成线程

6、分块
7、光栅化
栅格化，是指将图块转换为位图

8、合成


## http
1.构建请求：浏览器构建请求行信息 get/index.html http1.1。
2.查找缓存
3.准备ip和端口：通过域名系统(DNS)拿到ip地址
4.等待TCP队列
5.建立TCP连接：建立连接(三次握手)，传输数据，断开连接(四次挥手)
6.发起http请求：请求行，请求头，请求体(携带post传参)
7.服务器处理请求：响应行，响应头，响应体
8.服务器返回请求：浏览器开始渲染进程

## 缓存
浏览器缓存是将文件保存在客户端
页面的缓存状态是由header决定的
### 1.强缓存
response headers
http1.1 cache-control:max-age,s-maxage,public,private,no-cache,
no-store,must-revalidate
max-age:缓存最大的有效时间
s-maxage:用于共享缓存(CDN缓存)
public:指定响应会被缓存，并且在多用户间共享
private：响应只作为私有的缓存，不能在用户间共享。HTTP认证，响应会自动
设置为private
no-cache：指定不缓存响应，资源不进行缓存，加上private
no-store:绝对禁止缓存
must-revalidate:指定如果页面是过期的，则去服务器进行获取

http1.0 Expires=max-age+ 请求时间(cache-control 优先级更高)

### 2.协商缓存
response headers
#### 1、last-modified：
服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次请求，会向服务器传送if-modified-since报头，询问last-modified时间点之后资源是否被修改过。如果没有，返回304，使用缓存；如果修改过，则再次去服务器请求资源，返回200，最新资源

#### 2、etag：
根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器字符串传回服务器，服务端检查etag，验证资源是否已经修改，没修改返回304，空响应

#### 3、etag:解决的问题
a、某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新 
b、如果资源修改非常频繁，在秒以下的时间内进行修改，而Last-modified只能精确到秒 
c、一些资源的最后修改时间改变了，但是内容没改变，使用ETag就认为资源还是没有修改的。
last-modified：是根据文件的修改时间作唯一标示
etag：根据资源内容在服务器端的唯一标识符，更加准确的控制缓存

#### 4、last-modified/if-modified-since要配合cache-control
Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。
If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头:
If-Modified-Since:Last-Modified的值
web服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304,告知浏览器继续使用所保存的cache

#### Etag/If-None-Match 配合Cache-Control使用。
Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）.
If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头：
If-None-Match：Etag的值
web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定返回200或304。

#### LocalStorage和sessionStorage。



## 跨域

## 输入url显示页面过程
一.用户输入url
1.浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL

二.URL 请求过程
1.网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程

2.网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息

3.TCP三次握手建立连接，TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输

4.网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层

5.底层通过物理网络传输给目的服务器主机，紧接着目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层

6.目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层

7.应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了

8.网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型（Content-Type： application/octet-stream，下载），就将该请求交给下载管理器；如果是（Content-Type：text/html）类型，就通知浏览器进程获取到文档准备渲染

9.浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程。

10.浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程

11.浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页。

12.渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来





# 框架(vue react)


# 数据结构和算法

## 栈：只能操作一端
## 队列：可以操作两端

# 设计模式：
1.工厂模式:解决创建对象有重复的属性和方法
直接上代码
var createPerson=function(name,age){
    var obj=new Object()

    obj.name=name
    obj.age=age
    obj.getName=function(){
        return this.name
    }
    return obj
}
 创建实例
 var jc=createPerson('js',10)



# 工程化

# git  

# 工程化 技术难点 团队协作


